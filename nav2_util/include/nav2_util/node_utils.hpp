// Copyright (c) 2019 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef NAV2_UTIL__NODE_UTILS_HPP_
#define NAV2_UTIL__NODE_UTILS_HPP_

#include <string>

#include "rclcpp/rclcpp.hpp"

namespace nav2_util {

// clang-format off
/*
  其中包含了四个函数，分别用于处理节点名称、命名空间和节点创建等问题。

  - `sanitize_node_name` 函数用于将潜在节点名称中的无效字符替换为 `_`，以确保节点名称符合 ROS2 的规范。
  - `add_namespaces` 函数用于连接两个命名空间以生成绝对命名空间，即以 `/` 开头的命名空间。
  - `generate_internal_node_name` 函数用于向节点名称添加一些随机字符，以确保它在系统中是唯一的。这个函数会生成一个前缀加上 8 位随机数字的节点名称。
  - `generate_internal_node` 函数使用 `generate_internal_node_name` 函数生成的名称创建一个节点，并设置节点的参数服务和参数事件发布器为空。

  以上这些函数都是 navigation2 组件中 lifecycle_manager 功能的基础，可以帮助用户更好地管理 ROS2 节点的生命周期。
*/
// clang-format on

/// Replace invalid characters in a potential node name
/**
 * There is frequently a need to create internal nodes. They must have a name,
 * and commonly the name is based on some parameter related to the node's
 * purpose. However, only alphanumeric characters and '_' are allowed in node
 * names. This function replaces any invalid character with a '_'
 *
 * \param[in] potential_node_name Potential name but possibly with invalid charaters.
 * \return A copy of the input string but with non-alphanumeric characters replaced with '_'
 */
/**
 * @brief 用 '_' 替换潜在节点名称中的无效字符
 * @param[in] potential_node_name 潜在的节点名称，但可能包含无效字符。
 * @return 将非字母数字字符替换为 '_' 的输入字符串的副本
 */
std::string sanitize_node_name(const std::string& potential_node_name);

/// Concatenate two namespaces to produce an absolute namespace
/**
 * \param[in] top_ns The namespace to place first
 * \param[in] sub_ns The namespace to place after top_ns
 * \return An absolute namespace starting with "/"
 */
/**
 * @brief 连接两个命名空间以生成绝对命名空间
 * @param[in] top_ns 要放置在前面的命名空间
 * @param[in] sub_ns 放置在 top_ns 后面的命名空间
 * @return 以“/”开头的绝对命名空间
 */
std::string add_namespaces(const std::string& top_ns, const std::string& sub_ns = "");

/// Add some random characters to a node name to ensure it is unique in the system
/**
 * There are utility classes that create an internal private node to interact
 * with the system. These private nodes are given a generated name. If multiple
 * clients end up using the same service, there is the potential for node name
 * conflicts. To ensure node names are globally unique, this appends some random
 * numbers to the end of the prefix.
 *
 * \param[in] prefix A string to help understand the purpose of the node.
 * \return A copy of the prefix + '_' + 8 random digits. eg. prefix_12345678
 */
/**
 * @brief 向节点名称添加一些随机字符，以确保它在系统中是唯一的
 * @param[in] prefix 一个字符串，用于帮助理解节点的目的。
 * @return 前缀 + '_' + 8 个随机数字的副本。例如：prefix_12345678
 */
std::string generate_internal_node_name(const std::string& prefix = "");

/// Creates a node with a name as generated by generate_internal_node_name
/**
 *  Creates a node with the following settings:
 *  - name generated by generate_internal_node_name
 *  - no parameter services
 *  - no parameter event publisher
 *
 * \param[in] prefix A string to help understand the purpose of the node.
 * \return A shared_ptr to the node.
 */
/**
 * @brief 使用 generate_internal_node_name 生成的名称创建一个节点
 * @param[in] prefix 一个字符串，用于帮助理解节点的目的。
 * @return 指向节点的 shared_ptr。
 */
rclcpp::Node::SharedPtr generate_internal_node(const std::string& prefix = "");

// clang-format off
/*
  其中包含了三个函数，分别为 time_to_string、declare_parameter_if_not_declared 和 declare_parameter_if_not_declared。

  - time_to_string 函数用于生成一个伪随机数字字符串。该函数将当前系统时间转换为字符串以生成伪随机数字。如果输出字符串长度超过8位数，则只会用零填充，不会增加任何额外的随机性。
  - declare_parameter_if_not_declared 函数用于声明静态 ROS2 参数并将其设置为给定值。如果尚未声明，则该函数将声明静态 ROS2
  参数并将其设置为给定值。其中第一个函数重载版本使用 rclcpp::ParameterValue
  类型的默认参数值，而第二个函数重载版本使用 rclcpp::ParameterType
  类型的默认参数值。两个函数都可以选择性地传递参数描述符。

  以上是对该代码段的功能进行详细的总结和梳理，并且保留了代码中的已有英文注释并进行了翻译。
*/
// clang-format on

/// Generates a pseudo random string of digits.
/**
 * Generates pseudo random digits by converting the current system time to a
 * string. This means that any length more than 8 or so digits will just get
 * padded with zeros and doesn't add any additional randomness.
 *
 * \param[in] len Length of the output string
 * \return A string containing random digits
 */
/// 生成一个伪随机数字字符串。
/**
 * 将当前系统时间转换为字符串以生成伪随机数字。这意味着任何长度超过8位数的字符串都只会用零填充，不会增加任何额外的随机性。
 *
 * \param[in] len 输出字符串的长度
 * \return 包含随机数字的字符串
 */
std::string time_to_string(size_t len);

/// Declares static ROS2 parameter and sets it to a given value if it was not already declared
/* Declares static ROS2 parameter and sets it to a given value
 * if it was not already declared.
 *
 * \param[in] node A node in which given parameter to be declared
 * \param[in] param_name The name of parameter
 * \param[in] default_value Parameter value to initialize with
 * \param[in] parameter_descriptor Parameter descriptor (optional)
 */
/// 如果尚未声明，则声明静态ROS2参数并将其设置为给定值。
/* 如果尚未声明，则声明静态ROS2参数并将其设置为给定值。
 *
 * \param[in] node 要在其中声明给定参数的节点
 * \param[in] param_name 参数名称
 * \param[in] default_value 初始化参数值
 * \param[in] parameter_descriptor 参数描述符（可选）
 */
template <typename NodeT>
void declare_parameter_if_not_declared(
    NodeT node,
    const std::string& param_name,
    const rclcpp::ParameterValue& default_value,
    const rcl_interfaces::msg::ParameterDescriptor& parameter_descriptor =
        rcl_interfaces::msg::ParameterDescriptor()) {
  if (!node->has_parameter(param_name)) {
    node->declare_parameter(param_name, default_value, parameter_descriptor);
  }
}

/// Declares static ROS2 parameter with given type if it was not already declared
/* Declares static ROS2 parameter with given type if it was not already declared.
 *
 * \param[in] node A node in which given parameter to be declared
 * \param[in] param_type The type of parameter
 * \param[in] default_value Parameter value to initialize with
 * \param[in] parameter_descriptor Parameter descriptor (optional)
 */
/// 如果尚未声明，则声明具有给定类型的静态ROS2参数。
/* 如果尚未声明，则声明具有给定类型的静态ROS2参数。
 *
 * \param[in] node 要在其中声明给定参数的节点
 * \param[in] param_type 参数类型
 * \param[in] default_value 初始化参数值
 * \param[in] parameter_descriptor 参数描述符（可选）
 */
template <typename NodeT>
void declare_parameter_if_not_declared(
    NodeT node,
    const std::string& param_name,
    const rclcpp::ParameterType& param_type,
    const rcl_interfaces::msg::ParameterDescriptor& parameter_descriptor =
        rcl_interfaces::msg::ParameterDescriptor()) {
  if (!node->has_parameter(param_name)) {
    node->declare_parameter(param_name, param_type, parameter_descriptor);
  }
}

/*
  该函数用于获取所选节点及其插件的插件类型。实际上是寻找“.plugin”参数的值。如果未声明，则声明“.plugin”参数。如果获取失败，输出错误信息并退出程序。如果“.plugin”参数未定义，输出错误信息并退出程序。最后返回“.plugin”参数的值。
*/

/// Gets the type of plugin for the selected node and its plugin
/**
 * Gets the type of plugin for the selected node and its plugin.
 * Actually seeks for the value of "<plugin_name>.plugin" parameter.
 *
 * \param[in] node Selected node
 * \param[in] plugin_name The name of plugin the type of which is being searched for
 * \return A string containing the type of plugin (the value of "<plugin_name>.plugin" parameter)
 */
/**
 * @brief 获取所选节点及其插件的插件类型
 *
 * 获取所选节点及其插件的插件类型。
 * 实际上是寻找“<plugin_name>.plugin”参数的值。
 *
 * \param[in] node 所选节点
 * \param[in] plugin_name 正在搜索其类型的插件的名称
 * \return 包含插件类型（“<plugin_name>.plugin”参数的值）的字符串
 */
template <typename NodeT>
std::string get_plugin_type_param(NodeT node, const std::string& plugin_name) {
  declare_parameter_if_not_declared(
      node, plugin_name + ".plugin",
      rclcpp::PARAMETER_STRING);  // 如果未声明，则声明“<plugin_name>.plugin”参数
  std::string plugin_type;
  try {
    // 获取“<plugin_name>.plugin”参数的值
    if (!node->get_parameter(plugin_name + ".plugin", plugin_type)) {
      // 如果获取失败，输出错误信息并退出程序
      RCLCPP_FATAL(
          node->get_logger(), "Can not get 'plugin' param value for %s", plugin_name.c_str());
      exit(-1);
    }
    // 如果“<plugin_name>.plugin”参数未定义，输出错误信息并退出程序
  } catch (rclcpp::exceptions::ParameterUninitializedException& ex) {
    RCLCPP_FATAL(node->get_logger(), "'plugin' param not defined for %s", plugin_name.c_str());
    exit(-1);
  }

  return plugin_type;  // 返回“<plugin_name>.plugin”参数的值
}

}  // namespace nav2_util

#endif  // NAV2_UTIL__NODE_UTILS_HPP_
